---
title: "Analyses"
output: 
  html_document:
    toc: TRUE
    toc_float:
      collapsed: FALSE
    toc_depth: 2
    code_folding: hide
---

```{r setup, include=F}
knitr::opts_chunk$set(
  cache=T, comment=NA, warning=F, echo=T, error=F, 
  message=F, prompt=F, tidy=T, fig.height=4
  )
options(digits = 3, width = 120)
```

In what follows, you can find the analyses for the results we report in the paper. To see the underlying code, click on the button "code".

# Setup

We first load the packages; load and wrangle data; and extract sample characteristics and descriptives.

```{r results='hide'}
# install github packages
# devtools::install_github("tdienlin/td@v.0.0.2.3")  # uncomment to install

# define packages
packages <- c("cowplot", "devtools", "faoutlier", "GGally", "gganimate",
              "kableExtra", "knitr", "lavaan", "magrittr", "MVN", "psych", "pwr", 
              "quanteda", "semTools", "tidyverse", "td")

# load packages
lapply(packages, library, character.only = TRUE, quietly = TRUE)

# load data
# please note that in a prior step several different data sets were merged using information such as case_taken or IP-addresses. To guarantee the privacy of the participants, these data were deleted after merging.
d_raw <- read_csv("data/data_raw.csv")

# recode variables
d <- d_raw %>% 
  dplyr::rename(
    "male" = "SD01", 
    "age" = "SD02_01", 
    "state" = "SD03", 
    "edu_fac" = "SD04"
    ) %>% 
  mutate(
    
    #general
    version = factor(.$VE01_01, labels = c("Control", "Like", "Like & Dislike")),
    version_no = recode(version, "Control" = 1, "Like" = 2, "Like & Dislike" = 3),
    male = replace_na(.$male, "[3]") %>% dplyr::recode(., "männlich [1]" = 1, "weiblich [2]" = 0),
    age_grp = cut(.$age, 
                  breaks = c(0, 29, 39, 49, 59, 100), 
                  labels = c("<30", "30-39", "40-49", "50-59", ">59")),
    
    # contrasts
    lik_ctrl = recode(version, "Control" = 0, "Like" = 1),
    lik_ctrl = na_if(lik_ctrl, "Like & Dislike"),
    likdis_ctrl = recode(version, "Control" = 0, "Like & Dislike" = 1),
    likdis_ctrl = na_if(likdis_ctrl, "Like"),
    likdis_lik = recode(version, "Like" = 0, "Like & Dislike" = 1),
    likdis_lik = na_if(likdis_lik, "Control"),
    likdislik_ctrl = recode(version, "Control" = 0, "Like & Dislike" = 1),
    likdislik_ctrl = na_if(likdislik_ctrl, "Like"),
    
    # recode
    edu = recode(edu_fac, 
                 "Hauptschulabschluss/Volksschulabschluss" = 1, 
                 "Noch Schüler" = 1,
                 "Realschulabschluss (Mittlere Reife)" = 1,
                 "Abschluss Polytechnische Oberschule 10. Klasse (vor 1965: 8. Klasse)" = 1,
                 "Anderer Schulabschluss:" = 1,
                 "Fachhochschulreife (Abschluss einer Fachoberschule)" = 2,
                 "Abitur, allgemeine oder fachgebundene Hochschulreife (Gymnasium bzw. EOS)" = 2,
                 "Hochschulabschluss" = 3),
    PC01_03 = 8 - PC01_03, 
    SE01_05 = 8 - SE01_05, 
    SE01_06 = 8 - SE01_06,
    
    # behavioral data
    words = replace_na(.$words, 0),
    self_dis = words + (reactions * 2),
    time_read_MIN = time_read / 60,
    time_sum_min_t2 = TIME_SUM_t2 / 60,
    
    # take logarithm
    posts_log = log1p(.$post_count),
    time_log = log1p(.$time_read), 
    posts_read_count_log = log1p(.$posts_read_count),
    words_log = log1p(.$words),
    self_dis_log = log1p(self_dis)
  )

# variable labels
var_names <- c("Privacy concerns", 
               "General gratifications", 
               "Specific gratifications",
               "Privacy deliberation", 
               "Self-efficacy", 
               "General trust", 
               "Specific trust",
               "Self-disclosure")

var_names_breaks <- c("Privacy\nconcerns", 
                      "General\ngratifications", 
                      "Specific\ngratifications",
                      "Privacy\ndeliberation", 
                      "Self-\nefficacy", 
                      "General\ntrust", 
                      "Specific\ntrust",
                      "Self-\ndisclosure")

# Extract sample characteristics and descriptives.
# sample descriptives t1
n_t1 <- nrow(d)
age_t1_m <- mean(d$age, na.rm = TRUE)
male_t1_m <- mean(d$male, na.rm = TRUE)
college_t1_m <- table(d$edu)[3] / n_t1

# sample descriptives t2
n_t2 <- filter(d, !is.na(id_survey_t2)) %>% nrow()
age_t2_m <- filter(d, !is.na(id_survey_t2))$age %>% mean()
male_t2_m <- filter(d, !is.na(id_survey_t2))$male %>% mean(na.rm = TRUE)
college_t2_m <- filter(d, !is.na(id_survey_t2))$edu %>% table() %>% .[3] / n_t2

# descriptives users
n_users <- filter(d, !is.na(post_count)) %>% nrow()

# characteristics of posts
n_comments <- sum(d$post_count, na.rm = TRUE)
n_words <- sum(d$words, na.rm = TRUE)
n_time <- sum(d$time_read_MIN, na.rm = TRUE)
n_posts <- sum(d$post_count, na.rm = TRUE)

# filter unmatched cases
d <- filter(d, !is.na(post_count) & !is.na(id_survey_t2))  # Use only completes
n_matched <- nrow(d)

# save data file with all participants to compare results
d_all <- d
```

# Filter Participants

We filtered participants who answered the questionnaire in less than three minutes, which we considered to be unreasonably fast.

```{r}
# filter speeders
time_crit <- 3 # minimum time on survey
n_speeding <- nrow(filter(d, time_sum_min_t2 < time_crit))
d <- filter(d, time_sum_min_t2 >= time_crit) # Deletion of fast respondents
```

We inspected the data manually for cases with obvious response patterns. The following cases show extreme response patterns (alongside fast response times), and were hence removed.

```{r}
# identify response patterns
resp_pattern <- c(
  "ANIEVLK9F2SW", "BN4MAOWZO7W2"  # clear response pattern
  )
n_resp_pattern <- length(resp_pattern)
# infl_cases_tokens <- infl_cases_tokens[!infl_cases_tokens %in% resp_pattern]

d %>% 
  filter(case_token %in% resp_pattern) %>% 
  select(case_token, GR01_01:SE01_06, topics_entered:reactions, -SO01_01, TIME_SUM_t1, TIME_SUM_t2) %>% 
  kable() %>% 
  kable_styling("striped") %>% 
  scroll_box(width = "100%")
d %<>% filter(!case_token %in% resp_pattern)

# sample descriptives final data set
n_final <- nrow(d)
age_final_m <- mean(d$age)
male_final_m <- mean(d$male, na.rm = TRUE)
college_final_m <- table(d$edu)[[3]] / n_final
```

# Measures
## Privacy concerns
### Items

Using the participation platform I had ...

 1. ... concerns about what happens to my data.
 2. ... concerns about disclosing information about myself.
 3. ... no concerns.
 4. ... concerns that others could discover my real identity (i.e. my last and first name).
 5. ... concerns that information about myself could fall into wrong hands.
 6. ... concerns that others could discover what my political views are.
 7. ... concerns about my privacy.

### Distributions

```{r}
ggplot(gather(select(d, starts_with("PC01"))), 
                      mapping = aes(x = value)) +
  geom_bar() +
  facet_wrap(~key, nrow=1) + 
  theme_bw()

des_pricon <- select(d, starts_with("PC01")) %>% 
  apply(1, mean, na.rm = TRUE) %>% 
  as.data.frame() %>% 
  summarise(m = mean(., na.rm = TRUE), sd = sd(., na.rm = TRUE))
```

### CFA

```{r}
name <- "pricon"
model <- "
pri_con =~ PC01_01 + PC01_02 + PC01_03 + PC01_04 + PC01_05 + PC01_06 + PC01_07
"
fit <- sem(model = model, data = d, estimator = "MLR", missing = "ML")
```

Model fit:

```{r}
(factor_val <- fit_tab(fit, reliability = TRUE, scaled = TRUE))
assign(paste0(name, "_factor_val"), factor_val)
```

Factor loadings:

```{r}
inspect(fit,what="std")$lambda
```

Shows that PC01_03 doesn't load well. As it's an inverted item that's not surprising. Also from a theoretic perspective it's suboptional, because it doesn't explicitly focus on privacy, but just concerns in general. Will be deleted.

### CFA 2

```{r}
model <- "
pri_con =~ PC01_01 + PC01_02 + PC01_04 + PC01_05 + PC01_06 + PC01_07
"
fit <- sem(model = model, data = d, estimator = "MLR", missing = "ML")
```

Model fit:

```{r}
(factor_val <- fit_tab(fit, reliability = TRUE, scaled = TRUE))
assign(paste0(name, "_factor_val"), factor_val)
```

Factor loadings:

```{r}
inspect(fit,what="std")$lambda
```

Updated version shows good fit.

## Gratifications general
### Items

Using the participation platform ...
 
 1.	... had many benefits for me.
 2.	... has paid off for me.
 3.	... was worthwhile.
 4.	... was fun.
 5.	... has brought me further regarding content.

### Distributions

```{r}
ggplot(gather(select(d, starts_with("GR02"))), 
       mapping = aes(x = value)) +
  geom_bar() +
  facet_wrap(~key, nrow=1) + 
  theme_bw()

des_grats_gen <- select(d, starts_with("GR02")) %>% 
  apply(1, mean, na.rm = TRUE) %>% 
  as.data.frame() %>% 
  summarise(m = mean(., na.rm = TRUE), sd = sd(., na.rm = TRUE))
```

### CFA

```{r}
name <- "grats_general"
model <- "
grats_gen =~ GR02_01 + GR02_02 + GR02_03 + GR02_04 + GR02_05
"
fit <- sem(model = model, data = d, estimator = "MLR", missing = "ML")
```

Model fit:

```{r}
(factor_val <- fit_tab(fit, reliability = TRUE, scaled = TRUE))
assign(paste0(name, "_factor_val"), factor_val)
```

Factor loadings:

```{r}
inspect(fit,what="std")$lambda
```

## Gratifications specific
### Items

Using the participation platform it has been possible for me ...

_Information_

 1.	... to learn things I would not otherwise have noticed.
 2.	... to hear the opinion of others.
 3.	... to learn how other people tick.

_Relevance_

 4.	... to react to a subject that is very dear to me.
 5.	... to react to a subject that is important to me.
 6.	... to react to a subject that I am affected by.

_Political participation_

 7.	... to engage politically.
 8.	... to discuss political issues.
 9.	... to pursue my political interest.

_Idealism_

 10. ... to try to improve society.
 11. ... to advocate to something meaningful.
 12. ... to serve a good purpose.

_Extrinsic benefits_

 13. ... to do the responsible persons a favor.
 14. ... to soothe my guilty consciences.
 15. ... to fulfil my civic duty.

### Distributions

```{r fig.height=6}
ggplot(gather(select(d, starts_with("GR01"))), 
       mapping = aes(x = value)) +
  geom_bar() +
  facet_wrap(~key, nrow=2) + 
  theme_bw()

des_grats_spec <- select(d, starts_with("GR01")) %>% 
  apply(1, mean, na.rm = TRUE) %>% 
  as.data.frame() %>% 
  summarise(m = mean(., na.rm = TRUE), sd = sd(., na.rm = TRUE))
```

### CFA

```{r}
name <- "grats_specific"
model <- "
  grats_inf =~ GR01_01 + GR01_02 + GR01_03 
  grats_rel =~ GR01_04 + GR01_05 + GR01_06 
  grats_par =~ GR01_07 + GR01_08 + GR01_09
  grats_ide =~ GR01_10 + GR01_11 + GR01_12 
  grats_ext =~ GR01_13 + GR01_14 + GR01_15
  grats_spec =~ grats_inf + grats_rel + grats_par + grats_ide + grats_ext
"
fit <- sem(model = model, data = d, estimator = "MLR", missing = "ML")
```

Model fit:

```{r}
(factor_val <- fit_tab(fit, reliability = TRUE, scaled = TRUE))
assign(paste0(name, "_factor_val"), factor_val)
```

Factor loadings:

```{r}
inspect(fit,what="std")$lambda
```

## Privacy deliberation
### Items

Using the participation platform ...

 1. ... I have considered whether I could be disadvantaged by writing a comment.
 2. ... I have considered whether I could be advantaged by writing a comment.
 3. ... I have weighed up the advantages and disadvantages of writing a comment.
 4. ... I have thought about consequences of a possible comment.
 5. ... I have considered whether I should write a comment or not.

### Distributions

```{r}
ggplot(gather(select(d, starts_with("PD01"))), 
       mapping = aes(x = value)) +
  geom_bar() +
  facet_wrap(~key, nrow=1) + 
  theme_bw()

des_pridel <- select(d, starts_with("PD01")) %>% 
  apply(1, mean, na.rm = TRUE) %>% 
  as.data.frame() %>% 
  summarise(m = mean(., na.rm = TRUE), sd = sd(., na.rm = TRUE))
```

### CFA

```{r}
name <- "pridel"
model <- "
pri_delib =~ PD01_01 + PD01_02 + PD01_03 + PD01_04 + PD01_05
"
fit <- sem(model = model, data = d, estimator = "MLR", missing = "ML")
```

Model fit:

```{r}
(factor_val <- fit_tab(fit, reliability = TRUE, scaled = TRUE))
assign(paste0(name, "_factor_val"), factor_val)
```

Factor loadings:

```{r}
inspect(fit,what="std")$lambda
```

## Trust general
### Items

&nbsp;&nbsp;&nbsp;1. The other users seemed trustworthy.  
&nbsp;&nbsp;&nbsp;5. The operators of the participation platform seemed trustworthy.  
&nbsp;&nbsp;&nbsp;9. The website seemed trustworthy.  

### Distributions

```{r}
ggplot(gather(select(d, TR01_01, TR01_05, TR01_09)), 
       mapping = aes(x = value)) +
  geom_bar() +
  facet_wrap(~key, nrow=1) + 
  theme_bw()

des_trust_gen <- select(d, TR01_01, TR01_05, TR01_09) %>% 
  apply(1, mean, na.rm = TRUE) %>% 
  as.data.frame() %>% 
  summarise(m = mean(., na.rm = TRUE), sd = sd(., na.rm = TRUE))
```

### CFA

```{r}
name <- "trust_gen"
model <- "
trust =~ TR01_01 + a*TR01_05 + a*TR01_09
"
fit <- sem(model = model, data = d, estimator = "MLR", missing = "ML")
```

Model fit:

```{r}
(factor_val <- fit_tab(fit, reliability = TRUE, scaled = TRUE))
assign(paste0(name, "_factor_val"), factor_val)
```

Factor loadings:

```{r}
inspect(fit,what="std")$lambda
```

Note that we constrained Items 5 and Item 9 to be equal. Explanation: First, they are theoretically related. Second, not constraining would yield to just-identified model, for which model fit cannot be interpreted meaningfully.

## Trust specific
### Items

_Community_

 2.	The comments of other users were useful.
 3.	The other users had good intentions.
 4.	I could rely on the statements of other users.

_Provider_

 6.	The operators of the participation platform have done a good job.
 7.	It was important to the operators that the users are satisfied with the participation platform.
 8.	I could rely on the statements of the operators of the participation platform.

_Information System_

 10.	The website worked well.
 11.	I had the impression that my data was necessary for the use of the website.
 12.	I found the website useful.

### Distributions

```{r}
ggplot(gather(select(d, TR01_02:TR01_04, TR01_06:TR01_08, TR01_10:TR01_12)), 
       mapping = aes(x = value)) +
  geom_bar() +
  facet_wrap(~key, nrow=1) + 
  theme_bw()

des_trust_spec <- select(d, TR01_02:TR01_04, TR01_06:TR01_08, TR01_10:TR01_12) %>% 
  apply(1, mean, na.rm = TRUE) %>% 
  as.data.frame() %>% 
  summarise(m = mean(., na.rm = TRUE), sd = sd(., na.rm = TRUE))
```

### CFA

```{r}
name <- "trust_spec"
model <- "
trust_community =~ TR01_02 + TR01_03 + TR01_04
trust_provider =~ TR01_06 + TR01_07 + TR01_08
trust_system =~ TR01_10 + TR01_11 + TR01_12

trust =~ trust_community + trust_provider + trust_system
"
fit <- sem(model = model, data = d, estimator = "MLR", missing = "ML")
```

Model fit:

```{r warning=T}
(factor_val <- fit_tab(fit, reliability = TRUE, scaled = TRUE))
assign(paste0(name, "_factor_val"), factor_val)
```

Factor loadings:

```{r}
inspect(fit,what="std")$lambda
```

### CFA 2

Because there was Heywoodcase, we now also run a model in which the subdimensions `provider` and `system` are combined.

```{r}
name <- "trust_spec"
model <- "
trust_community =~ TR01_02 + TR01_03 + TR01_04
trust_provider =~ TR01_06 + TR01_07 + TR01_08 + TR01_10 + TR01_11 + TR01_12
trust =~ b*trust_community + b*trust_provider
"
fit <- sem(model = model, data = d, estimator = "MLR", missing = "ML")
```

Model fit:

```{r}
(factor_val <- fit_tab(fit, reliability = TRUE, scaled = TRUE))
assign(paste0(name, "_factor_val"), factor_val)
```

Factor loadings:

```{r}
inspect(fit,what="std")$lambda
```
Warning disappears, results show adequate fit.

## Self-efficacy
### Items

 1. In principle, I felt able to write a comment.
 2. I felt technically competent enough to write a comment.
 3. In terms of the topic, I felt competent enough to express my opinion.
 4. I found it easy to express my opinion regarding the topic.
 5. I found it complicated to write a comment.
 6. I was overburdened to write a comment.

### Distributions

```{r}
ggplot(gather(select(d, starts_with("SE01"))), 
       mapping = aes(x = value)) +
  geom_bar() +
  facet_wrap(~key, nrow=1) + 
  theme_bw()

des_selfeff <- select(d, starts_with("SE01")) %>% 
  apply(1, mean, na.rm = TRUE) %>% 
  as.data.frame() %>% 
  summarise(m = mean(., na.rm = TRUE), sd = sd(., na.rm = TRUE))
```

### CFA

```{r}
name <- "self-eff"
model <- "
self_eff =~ SE01_01 + SE01_02 + SE01_03 + SE01_04 + SE01_05 + SE01_06
"
fit <- sem(model = model, data = d, estimator = "MLR", missing = "ML")
```

Model fit:

```{r}
(factor_val <- fit_tab(fit, reliability = TRUE, scaled = TRUE))
assign(paste0(name, "_factor_val"), factor_val)
```

Factor loadings:

```{r}
inspect(fit,what="std")$lambda
```

Shows significant misfit. We will delete inverted items, while allowing covariations between Items 1 and 2 (tech-oriented) and Items 3 and 4 (topic-oriented). 

### CFA 2

```{r}
name <- "selfeff"
model <- "
self_eff_pos =~ SE01_01 + SE01_02 + SE01_03 + SE01_04
SE01_01 ~~ x*SE01_02
SE01_03 ~~ x*SE01_04
"
fit <- sem(model = model, data = d, estimator = "MLR", missing = "ML")
```

Model fit:

```{r}
(factor_val <- fit_tab(fit, reliability = TRUE, scaled = TRUE))
assign(paste0(name, "_factor_val"), factor_val)
```

Factor loadings:

```{r}
inspect(fit,what="std")$lambda
```

Adapted version shows better and adequate fit.

## Baseline model

In what follows, please find the results of all variables combined in one model. This model will be used to extract factor scores.

```{r}
model_baseline <- "
  pri_con =~ PC01_01 + PC01_02 + PC01_04 + PC01_05 + PC01_06 + PC01_07
  grats_gen =~ GR02_01 + GR02_02 + GR02_03 + GR02_04 + GR02_05
  grats_inf =~ GR01_01 + GR01_02 + GR01_03 
  grats_rel =~ GR01_04 + GR01_05 + GR01_06 
  grats_par =~ GR01_07 + GR01_08 + GR01_09
  grats_ide =~ GR01_10 + GR01_11 + GR01_12 
  grats_ext =~ GR01_13 + GR01_14 + GR01_15
  grats_spec =~ grats_inf + grats_rel + grats_par + grats_ide + grats_ext
  pri_delib =~ PD01_01 + PD01_02 + PD01_03 + PD01_04 + PD01_05
  trust_gen =~ TR01_01 + TR01_05 + TR01_09
  trust_community =~ TR01_02 + TR01_03 + TR01_04
  trust_provider =~ TR01_06 + TR01_07 + TR01_08 + TR01_10 + TR01_11 + TR01_12
  trust_spec =~ trust_community + trust_provider
  self_eff =~ SE01_01 + SE01_02 + SE01_03 + SE01_04
    SE01_01 ~~ x*SE01_02
    SE01_03 ~~ x*SE01_04
  self_dis_lg =~ self_dis_log
  
  self_dis_lg ~~ a1*pri_con + b1*grats_gen + c1*pri_delib + d1*self_eff + e1*trust_spec + f1*trust_gen + g1*grats_spec
"
fit_baseline <- sem(model_baseline, data = d, missing = "ML")
summary(fit_baseline, standardized = TRUE, fit.measures = TRUE)
```

# Descriptive analyses

We first report the factor validity of all variables combined.

```{r}
# extract model predicted values for items & calc means
d_fs <- lavPredict(fit_baseline, type = "ov") %>% 
  as.data.frame() %>% 
  mutate(version = d$version, 
         grats_gen_fs = rowMeans(select(., starts_with("GR02"))),
         grats_spec_fs = rowMeans(select(., starts_with("GR01"))), 
         pri_con_fs = rowMeans(select(., starts_with("PC01"))),
         trust_gen_fs = rowMeans(select(., TR01_01, TR01_05, TR01_09)),
         trust_spec_fs = rowMeans(select(., TR01_02: TR01_04, TR01_06 : TR01_12)),
         pri_del_fs = rowMeans(select(., starts_with("PD01"))),
         self_eff_fs = rowMeans(select(., starts_with("SE01")))) %>%
  select(version, pri_con_fs, grats_gen_fs, grats_spec_fs, pri_del_fs, self_eff_fs, trust_gen_fs, trust_spec_fs, self_dis_log)

# combine d with d factor scores
d %<>% cbind(select(d_fs, -version, -self_dis_log))

# rename for plotting
d_fs %<>% set_names(c("version", var_names_breaks))

# means of model predicted values
des <- rbind(des_pricon,
             des_grats_gen,
             des_grats_spec,
             des_pridel,
             des_selfeff,
             des_trust_gen,
             des_trust_spec)

factor_val_tab <- rbind(pricon_factor_val,
                        grats_general_factor_val,
                        grats_specific_factor_val,
                        pridel_factor_val,
                        selfeff_factor_val,
                        trust_gen_factor_val,
                        trust_spec_factor_val) %$%
  cbind(des[-8, ], .) %>%
  set_rownames(var_names[-8])

factor_val_tab %>% 
  kable() %>% 
  kable_styling("striped") %>% 
  scroll_box(width = "100%")
```

In what follows, we report zero-order correlations, distributions, and scatterplots of the variables' factor scores.

```{r fig.height=8, fig.width=8}
fig_fs_cor <- ggpairs(
  select(d_fs, -version),
  upper = list(continuous = "cor"),
  lower = list(continuous = wrap(td::scat_plot, coords = c(1, 7, 0, 7)))) +
  theme_bw()
print(fig_fs_cor)
```

# Power analyses

In what follows, we report power analyses for our study. Please note that we conduct a rudimentary power-analysis, assuming bivariate correlations. To explain, at the time we were not yet aware of power analyses for multivariate structural equation models. 

```{r include=F}
# define pwr-criteria
z_crit <- 1.96
alpha <- .05
power_desired <- .95
r_sesoi <- .10
```

We first estimate the sample size necessary to find small effects in 95% of all cases.

```{r}
# estimate pwr-samplesize
pwr.r.test(r = r_sesoi, sig.level = alpha, power = power_desired, alternative = "greater") %T>%
  print %$% 
  n %>% 
  round(0) ->
  n_desired
```

We then compute the power we have achieved with our finale sample size to detect small effects.

```{r}
# compute pwr-achieved
pwr.r.test(n = n_final, r = r_sesoi, sig.level = alpha, alternative = "greater") %T>%
  print %$% 
  power %>% 
  round(2) ->
  power_achieved
```

We finally compute what effect size we are likely to find in 95% of all cases given our final sample size.

```{r}
# estimate pwr-sensitivity
pwr.r.test(n = n_final, power = power_desired, sig.level = alpha, alternative = "greater") %T>%
  print %$% 
  r %>% 
  round(2) ->
  r_sensitive
```

# Assumptions
## Multivariate normal distribution

```{r}
# create subset of data with all items that were used
d_sub <- d[, c("self_dis_log", "GR02_01", "GR02_02", "GR02_03", "GR02_04", "GR02_05", "PC01_01", "PC01_02", "PC01_04", "PC01_05", "PC01_06", "PC01_07", "TR01_02", "TR01_03", "TR01_04", "TR01_06", "TR01_07", "TR01_08", "TR01_10", "TR01_11", "TR01_12", "PD01_01", "PD01_02", "PD01_03", "PD01_04", "PD01_05", "SE01_01", "SE01_02", "SE01_03", "SE01_04", "male", "age", "edu")]

# test multivariate normal distribution
mvn_result <- mvn(d_sub, mvnTest = "mardia")
mvn_result$multivariateNormality
```

Shows that multivariate normal distribution is violated. We hence use maximum likelihood estimation with robust standard errors and a Satorra-Bentler scaled test statistic.

## Influential cases

In what follows we test for influential cases in baseline model, to detect potentially corrupt data (e.g., people who provided response patterns). Specifically, we compute Cook's distance.

```{r eval=T}
cooks_dis <- gCD(d, model_baseline)
plot(cooks_dis)
```

The following ten cases have a particularly strong influence on the baseline model.

```{r eval=T}
infl_cases <- invisible(rownames(print(cooks_dis)))
```

Let's inspect these cases.

```{r eval=T}
infl_cases_tokens <- d[infl_cases, "case_token"] %>% as_vector()
d %>% 
  filter(case_token %in% infl_cases_tokens) %>% 
  select(case_token, GR01_01:SE01_06, topics_entered:reactions, -SO01_01, TIME_SUM_t1, TIME_SUM_t2) %>% 
  kable() %>% 
  kable_styling("striped") %>% 
  scroll_box(width = "100%")
```

These data do not reveal potential cases of response patterns. Indeed, answer times suggest that respondents were diligent.

# Results
## Privacy calculus
### Model "Peregistered"

```{r}
model <- "
pri_con =~ PC01_01 + PC01_02 + PC01_04 + PC01_05 + PC01_06 + PC01_07 
grats_gen =~ GR02_01 + GR02_02 + GR02_03 + GR02_04 + GR02_05
pri_delib =~ PD01_01 + PD01_02 + PD01_03 + PD01_04 + PD01_05
self_eff =~ SE01_01 + SE01_02 + SE01_03 + SE01_04
  SE01_01 ~~ x*SE01_02
  SE01_03 ~~ x*SE01_04
trust_community =~ TR01_02 + TR01_03 + TR01_04
trust_provider =~ TR01_06 + TR01_07 + TR01_08 + TR01_10 + TR01_11 + TR01_12
trust_spec =~ trust_community + trust_provider

self_dis_log ~ a1*pri_con + b1*grats_gen + c1*pri_delib + d1*self_eff + e1*trust_spec

# Covariates
self_dis_log + GR02_01 + GR02_02 + GR02_03 + GR02_04 + GR02_05 + PC01_01 + PC01_02 + PC01_04 + PC01_05 + PC01_06 + PC01_07 + TR01_02 + TR01_03 + TR01_04 + TR01_06 + TR01_07 + TR01_08 + TR01_10 + TR01_11 + TR01_12 + PD01_01 + PD01_02 + PD01_03 + PD01_04 + PD01_05 + SE01_01 + SE01_02 + SE01_03 + SE01_04 ~ male + age + edu
"
fit_prereg <- sem(model, data = d, estimator = "MLR", missing = "ML")
summary(fit_prereg, fit = TRUE, std = TRUE)
rsquare_fit_prereg <- inspect(fit_prereg, what = "rsquare")["self_dis_log"]
```

### Model "Adapted"

Building on the preregistered model, instead of general gratifications and specific trust, we now use specific gratifications and general trust.

```{r}
model <- "
pri_con =~ PC01_01 + PC01_02 + PC01_04 + PC01_05 + PC01_06 + PC01_07
grats_inf =~ GR01_01 + GR01_02 + GR01_03 
grats_rel =~ GR01_04 + GR01_05 + GR01_06 
grats_par =~ GR01_07 + GR01_08 + GR01_09
grats_ide =~ GR01_10 + GR01_11 + GR01_12 
grats_ext =~ GR01_13 + GR01_14 + GR01_15
grats_spec =~ grats_inf + grats_rel + grats_par + grats_ide + grats_ext
pri_delib =~ PD01_01 + PD01_02 + PD01_03 + PD01_04 + PD01_05
self_eff =~ SE01_01 + SE01_02 + SE01_03 + SE01_04
  SE01_01 ~~ x*SE01_02
  SE01_03 ~~ x*SE01_04
trust_gen =~ TR01_01 + TR01_05 + TR01_09

self_dis_log ~ a1*pri_con + b1*grats_spec + c1*pri_delib + d1*self_eff + e1*trust_gen

# Covariates
self_dis_log + GR01_01 + GR01_02 + GR01_03 + GR01_04 + GR01_05 + GR01_06 + GR01_07 + GR01_08 + GR01_09 + GR01_10 + GR01_11 + GR01_12 + GR01_13 + GR01_14 + GR01_15 + PC01_01 + PC01_02 + PC01_04 + PC01_05 + PC01_06 + PC01_07 + TR01_01 + TR01_05 + TR01_09 + PD01_01 + PD01_02 + PD01_03 + PD01_04 + PD01_05 + SE01_01 + SE01_02 + SE01_03 + SE01_04 ~ male + age + edu
"
fit_adapted <- sem(model, data = d, estimator = "MLR", missing = "ML", missing = "ML")
summary(fit_adapted, fit = TRUE, std = TRUE)
rsquare_fit_adapted <- inspect(fit_adapted, what = "rsquare")["self_dis_log"]
```

### Model "Simple"

We now use only variables, that is specific gratifications and privacy concerns.

```{r}
model <- "
pri_con =~ PC01_01 + PC01_02 + PC01_04 + PC01_05 + PC01_06 + PC01_07  
grats_inf =~ GR01_01 + GR01_02 + GR01_03 
grats_rel =~ GR01_04 + GR01_05 + GR01_06 
grats_par =~ GR01_07 + GR01_08 + GR01_09
grats_ide =~ GR01_10 + GR01_11 + GR01_12 
grats_ext =~ GR01_13 + GR01_14 + GR01_15
grats_spec =~ grats_inf + grats_rel + grats_par + grats_ide + grats_ext

self_dis_log ~ a1*pri_con + b1*grats_spec

# Covariates
self_dis_log + GR01_01 + GR01_02 + GR01_03 + GR01_04 + GR01_05 + GR01_06 + GR01_07 + GR01_08 + GR01_09 + GR01_10 + GR01_11 + GR01_12 + GR01_13 + GR01_14 + GR01_15 + PC01_01 + PC01_02 + PC01_04 + PC01_05 + PC01_06 + PC01_07 ~ male + age + edu
"
fit_simple <- sem(model, data = d, estimator = "MLR", missing = "ML")
summary(fit_simple, fit = TRUE, std = TRUE)
rsquare_fit_simple <- inspect(fit_simple, what = "rsquare")["self_dis_log"]
```

### Comparison

```{r}
model_comp_tab <- data.frame(
  preregistered = fitmeasures(fit_prereg, c("BIC", "AIC")),
  adapted = fitmeasures(fit_adapted, c("BIC", "AIC")),
  simple = fitmeasures(fit_simple, c("BIC", "AIC"))) %>% 
  t() %T>%
  print()
```

### Visualization

```{r}
# extract coeffs
d_coeffs_baseline <- coeffs_tab(fit_baseline, c("a1", "b1", "c1", "d1", "e1", "f1", "g1")) %>% 
  mutate(Model = rep("Bivariate\nrelations", 7),
         Predictor = c("Privacy\nconcern", "Grats.\ngeneral", "Privacy\ndelib.", "Self-\nefficacy", "Trust\nspecific", "Trust\ngeneral", "Grats.\nspecific"))

d_coeffs_prereg <- coeffs_tab(fit_prereg, c("a1", "b1", "c1", "d1", "e1")) %>% 
  mutate(Model = rep("Preregistered\nmodel", 5),
         Predictor = c("Privacy\nconcern", "Grats.\ngeneral", "Privacy\ndelib.", "Self-\nefficacy", "Trust\nspecific"))

d_coeffs_adapted <- coeffs_tab(fit_adapted, c("a1", "b1", "c1", "d1", "e1")) %>% 
  mutate(Model = rep("Adapted\nmodel", 5),
         Predictor = c("Privacy\nconcern", "Grats.\nspecific", "Privacy\ndelib.", "Self-\nefficacy", "Trust\ngeneral"))

d_coeffs_simple <- coeffs_tab(fit_simple, c("a1", "b1")) %>% 
  mutate(Model = rep("Simple\nmodel", 2),
         Predictor = c("Privacy\nconcern", "Grats.\nspecific"))

d_coeffs <- rbind(d_coeffs_baseline, d_coeffs_prereg, d_coeffs_adapted, d_coeffs_simple) %>% 
  mutate(Predictor = factor(Predictor, c("Trust\ngeneral", "Trust\nspecific", "Self-\nefficacy", "Privacy\ndelib.", "Privacy\nconcern", "Grats.\nspecific", "Grats.\ngeneral")),
         Model = factor(Model, c("Bivariate\nrelations", "Preregistered\nmodel", "Adapted\nmodel", "Simple\nmodel"))
  )

# plot coeffs
fig_coeffs <- ggplot(d_coeffs, aes(x = b, y = Predictor)) + 
  geom_vline(xintercept = 0, lwd = .75, colour = "darkgrey") + 
  geom_point(size = 2) +
  geom_errorbarh(aes(xmin = ll, xmax = ul), 
                lwd = .75, colour = "grey", height = .2) +
  geom_errorbarh(aes(xmin = ll, xmax = ul),
                lwd = .75, colour = "black", height = .2) +
  facet_grid(~ Model) +
  guides(color = FALSE, shape = FALSE) + 
  theme_bw() +
  theme(axis.title.x=element_blank(),
        axis.title.y = element_blank(),
        plot.title = element_text(hjust = .5),
        panel.spacing = unit(.9, "lines"),
        text = element_text(size = 12)) +
  coord_cartesian(xlim = c(-1.5, 1.5))

fig_coeffs
```

## Effects of popularity cues
### Visualisation

The easiest way to assess the effect of the experimental manipulation on the variables is by visualizing their means. If 95% confidence intervals don't overlap, the variables differ significantly across the conditions. One can quickly see that there aren't any major effects.

```{r}
fig_fs_m <- ggplot(
  gather(d_fs, variable, value, -version) %>% 
    mutate(variable = factor(variable, levels = var_names_breaks)),
  aes(x = version, y = value, fill = version)) +
  stat_summary(fun.y = mean, geom = "bar") +
  stat_summary(aes(label=round(..y.., 2)), fun.y = mean, geom = "text", 
               vjust = 2, size = 3) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = .75) +
  facet_wrap(~ variable, nrow = 2) + 
  theme_bw() +
  theme(axis.title.y = element_blank(),
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        plot.title = element_text(hjust = .5),
        panel.spacing = unit(.9, "lines"),
        text = element_text(size = 12),
        legend.position="bottom",
        legend.title = element_blank()) +
  coord_cartesian(ylim = c(0, 7)) +
  scale_fill_brewer(palette="Greys")
fig_fs_m
```

### Preregistered

In what follows, we also report explicit statistical tests of the differences between the conditions using contrasts. 

However, please note that several models did not converge. This is likely because the models remain complex, while the sample size significantly decreases (i.e., only 2/3 of prior models).

For these models, we report less complex versions using factors scores, which converge successfully.

#### Like vs. Control

```{r}
model <- "
pri_con =~ PC01_01 + PC01_02 + PC01_04 + PC01_05 + PC01_06 + PC01_07
grats_gen =~ GR02_01 + GR02_02 + GR02_03 + GR02_04 + GR02_05
pri_delib =~ PD01_01 + PD01_02 + PD01_03 + PD01_04 + PD01_05
self_eff =~ SE01_01 + SE01_02 + SE01_03 + SE01_04
  SE01_01 ~~ x*SE01_02
  SE01_03 ~~ x*SE01_04
trust_community =~ TR01_02 + TR01_03 + TR01_04
trust_provider =~ TR01_06 + TR01_07 + TR01_08 + TR01_10 + TR01_11 + TR01_12
trust_spec =~ trust_community + trust_provider

pri_con + grats_gen + pri_delib + self_eff + trust_spec ~ lik_ctrl
self_dis_log ~ a*pri_con + b*grats_gen + c*pri_delib + d*self_eff + e*trust_spec + f*lik_ctrl

# Covariates
self_dis_log + GR02_01 + GR02_02 + GR02_03 + GR02_04 + GR02_05 + PC01_01 + PC01_02 + PC01_04 + PC01_05 + PC01_06 + PC01_07 + TR01_02 + TR01_03 + TR01_04 + TR01_06 + TR01_07 + TR01_08 + TR01_10 + TR01_11 + TR01_12 + PD01_01 + PD01_02 + PD01_03 + PD01_04 + PD01_05 + SE01_01 + SE01_02 + SE01_03 + SE01_04 ~ male + age + edu
"
fit_lik_ctrl <- sem(model = model, data = dplyr::filter(d, !is.na(lik_ctrl)), estimator = "MLR", missing = "ML")
summary(fit_lik_ctrl, fit = TRUE, std = TRUE)
```

Model did not converge. It's likely too complex given the reduced number of participants. The trust subdimension "provider" seems to cause trouble. Will hence be substituted with factor score.

```{r}
model <- "
pri_con =~ PC01_01 + PC01_02 + PC01_04 + PC01_05 + PC01_06 + PC01_07
grats_gen =~ GR02_01 + GR02_02 + GR02_03 + GR02_04 + GR02_05
pri_delib =~ PD01_01 + PD01_02 + PD01_03 + PD01_04 + PD01_05
self_eff =~ SE01_01 + SE01_02 + SE01_03 + SE01_04
  SE01_01 ~~ x*SE01_02
  SE01_03 ~~ x*SE01_04
trust_spec =~ trust_spec_fs

pri_con + grats_gen + pri_delib + self_eff + trust_spec ~ lik_ctrl
self_dis_log ~ a*pri_con + b*grats_gen + c*pri_delib + d*self_eff + e*trust_spec + f*lik_ctrl

# Covariates
self_dis_log + GR02_01 + GR02_02 + GR02_03 + GR02_04 + GR02_05 + PC01_01 + PC01_02 + PC01_04 + PC01_05 + PC01_06 + PC01_07 + PD01_01 + PD01_02 + PD01_03 + PD01_04 + PD01_05 + SE01_01 + SE01_02 + SE01_03 + SE01_04 ~ male + age + edu
"
fit_lik_ctrl <- sem(model = model, data = dplyr::filter(d, !is.na(lik_ctrl)), estimator = "MLR", missing = "ML")
summary(fit_lik_ctrl, fit = TRUE, std = TRUE)
```

Now converges sucessfully.

#### Like & Dislike vs. Control

```{r}
model <- "
pri_con =~ PC01_01 + PC01_02 + PC01_04 + PC01_05 + PC01_06 + PC01_07
grats_gen =~ GR02_01 + GR02_02 + GR02_03 + GR02_04 + GR02_05
pri_delib =~ PD01_01 + PD01_02 + PD01_03 + PD01_04 + PD01_05
self_eff =~ SE01_01 + SE01_02 + SE01_03 + SE01_04
  SE01_01 ~~ x*SE01_02
  SE01_03 ~~ x*SE01_04
trust_community =~ TR01_02 + TR01_03 + TR01_04
trust_provider =~ TR01_06 + TR01_07 + TR01_08 + TR01_10 + TR01_11 + TR01_12
trust_spec =~ trust_community + trust_provider

pri_con + grats_gen + pri_delib + self_eff + trust_spec ~ likdis_ctrl
self_dis_log ~ a*pri_con + b*grats_gen + c*pri_delib + d*self_eff + e*trust_spec + f*likdis_ctrl

# Covariates
self_dis_log + GR02_01 + GR02_02 + GR02_03 + GR02_04 + GR02_05 + PC01_01 + PC01_02 + PC01_04 + PC01_05 + PC01_06 + PC01_07 + TR01_02 + TR01_03 + TR01_04 + TR01_06 + TR01_07 + TR01_08 + TR01_10 + TR01_11 + TR01_12 + PD01_01 + PD01_02 + PD01_03 + PD01_04 + PD01_05 + SE01_01 + SE01_02 + SE01_03 + SE01_04 ~ male + age + edu
"
fit_likdis_ctrl <- sem(model = model, data = dplyr::filter(d, !is.na(likdis_ctrl)), estimator = "MLR", missing = "ML")
summary(fit_likdis_ctrl, fit = TRUE, std = TRUE)
```

Again, does not converge; will use `Trust Specific` as factor score.

```{r}
model <- "
pri_con =~ PC01_01 + PC01_02 + PC01_04 + PC01_05 + PC01_06 + PC01_07
grats_gen =~ GR02_01 + GR02_02 + GR02_03 + GR02_04 + GR02_05
pri_delib =~ PD01_01 + PD01_02 + PD01_03 + PD01_04 + PD01_05
self_eff =~ SE01_01 + SE01_02 + SE01_03 + SE01_04
  SE01_01 ~~ x*SE01_02
  SE01_03 ~~ x*SE01_04
trust_spec =~ trust_spec_fs

pri_con + grats_gen + pri_delib + self_eff + trust_spec ~ likdis_ctrl
self_dis_log ~ a*pri_con + b*grats_gen + c*pri_delib + d*self_eff + e*trust_spec + f*likdis_ctrl

# Covariates
self_dis_log + GR02_01 + GR02_02 + GR02_03 + GR02_04 + GR02_05 + PC01_01 + PC01_02 + PC01_04 + PC01_05 + PC01_06 + PC01_07 + PD01_01 + PD01_02 + PD01_03 + PD01_04 + PD01_05 + SE01_01 + SE01_02 + SE01_03 + SE01_04 ~ male + age + edu
"
fit_likdis_ctrl <- sem(model = model, data = dplyr::filter(d, !is.na(likdis_ctrl)), estimator = "MLR", missing = "ML")
summary(fit_likdis_ctrl, fit = TRUE, std = TRUE)
```

#### Like & Dislike vs. Like

```{r}
model <- "
pri_con =~ PC01_01 + PC01_02 + PC01_04 + PC01_05 + PC01_06 + PC01_07
grats_gen =~ GR02_01 + GR02_02 + GR02_03 + GR02_04 + GR02_05
pri_delib =~ PD01_01 + PD01_02 + PD01_03 + PD01_04 + PD01_05
self_eff =~ SE01_01 + SE01_02 + SE01_03 + SE01_04
  SE01_01 ~~ x*SE01_02
  SE01_03 ~~ x*SE01_04
trust_community =~ TR01_02 + TR01_03 + TR01_04
trust_provider =~ TR01_06 + TR01_07 + TR01_08 + TR01_10 + TR01_11 + TR01_12
trust_spec =~ trust_community + trust_provider

pri_con + grats_gen + pri_delib + self_eff + trust_spec ~ likdis_lik
self_dis_log ~ a*pri_con + b*grats_gen + c*pri_delib + d*self_eff + e*trust_spec + f*likdis_lik

# Covariates
self_dis_log + GR02_01 + GR02_02 + GR02_03 + GR02_04 + GR02_05 + PC01_01 + PC01_02 + PC01_04 + PC01_05 + PC01_06 + PC01_07 + TR01_02 + TR01_03 + TR01_04 + TR01_06 + TR01_07 + TR01_08 + TR01_10 + TR01_11 + TR01_12 + PD01_01 + PD01_02 + PD01_03 + PD01_04 + PD01_05 + SE01_01 + SE01_02 + SE01_03 + SE01_04 ~ male + age + edu
"

fit_likdis_lik <- sem(model = model, data = dplyr::filter(d, !is.na(likdis_lik)), estimator = "MLR", missing = "ML")
summary(fit_likdis_lik, fit = TRUE, std = TRUE)
```

This time, does converge, no need to change model.

```{r SaveData, include=F, cache=F}
write.csv(d, file = "data/data.csv", row.names = FALSE)
save(d, d_raw, d_all, d_fs,
     fit_baseline, fit_prereg, fit_adapted, fit_simple,
     fig_fs_m, fig_fs_cor, fig_coeffs,
     des_pridel,
     model_comp_tab, factor_val_tab,
     n_comments, n_desired, n_posts, n_speeding, n_time, n_words,
     n_comments, n_words, n_time, n_posts, n_speeding,
     n_users, n_final,
     # infl_cases, infl_cases_tokens, 
     resp_pattern, n_resp_pattern,
     n_t1, age_t1_m, male_t1_m, college_t1_m,
     n_t2, age_t2_m, male_t2_m, college_t2_m,
     n_matched, n_final, age_final_m, male_final_m, college_final_m,
     r_sesoi, r_sensitive, power_achieved,
     rsquare_fit_prereg, rsquare_fit_adapted, rsquare_fit_simple,
     file = "data/workspace.RData"
     )
```